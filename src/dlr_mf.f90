      !
      !
      ! This file contains subroutines to work with the discrete Lehmann
      ! representation in Matsubara frequency
      !
      !




      !> Get DLR frequency nodes and Matsubara frequency nodes
      !!
      !! @param[in]     lambda  dimensionless cutoff parameter
      !! @param[in]     eps     DLR error tolerance
      !! @param[in]     nmax    Matsubara frequency cutoff
      !! @param[in,out] r       On input, maximum possible number of DLR
      !!                          basis functions, defining input size
      !!                          of various arrays; on output, number
      !!                          of DLR basis functions.
      !! @param[out]    dlrrf   DLR frequency nodes
      !! @param[out]    dlrmf   DLR Matsubara frequency nodes

      subroutine dlr_buildmf(lambda,eps,nmax,r,dlrrf,dlrmf)

      implicit none
      integer nmax,r,dlrmf(r)
      real *8 lambda,eps,dlrrf(r)

      integer p,npt,npo,nt,no
      integer, allocatable :: oidx(:)
      real *8 kerr(2)
      real *8, allocatable :: kmat(:,:),t(:),om(:)


      ! Set parameters for the fine grid based on lambda

      call gridparams(lambda,p,npt,npo,nt,no)


      ! Get fine composite Chebyshev discretization of K(tau,omega)

      allocate(kmat(nt,no),t(nt),om(no))

      call kfine_cc(lambda,p,npt,npo,t,om,kmat,kerr)


      ! Select real frequency points for DLR basis

      r = 500 ! Upper bound on possible DLR rank

      allocate(oidx(r))

      call dlr_rf(lambda,eps,nt,no,om,kmat,r,dlrrf,oidx)


      ! Get DLR Matsubara frequency grid

      call dlr_mf(nmax,r,dlrrf,dlrmf)

      end subroutine dlr_buildmf





      !> Get DLR Matsubara frequency nodes
      !!
      !! @param[in]  nmax   Matsubara frequency cutoff
      !! @param[in]  r      number of DLR basis functions
      !! @param[in]  dlrrf  DLR frequency nodes
      !! @param[out] dlrmf  DLR Matsubara frequency nodes

      subroutine dlr_mf(nmax,r,dlrrf,dlrmf)

      implicit none
      integer nmax,r,dlrmf(r)
      real *8 dlrrf(r)

      integer i,k,info
      integer, allocatable :: ns(:),list(:)
      real *8, allocatable :: work(:)
      complex *16, allocatable :: poles(:,:)
      complex *16, external :: kfunf_mf

      ! Get matrix of Fourier transforms of DLR basis functions

      allocate(poles(r,2*nmax+1),ns(2*nmax+1))

      ns = (/(i, i=-nmax,nmax)/)

      do i=1,2*nmax+1
        do k=1,r
          
          poles(k,i) = kfunf_mf(ns(i),dlrrf(k))
          
        enddo
      enddo

      ! --- Select Matsubara frequency nodes by pivoted QR on rows of
      ! Fourier transformed K matrix ---

      allocate(list(2*nmax+1),work(2*nmax+1))

      ! Pivoted QR

      call idzr_qrpiv(r,2*nmax+1,poles,r,list,work)

      ! Rearrange indices to get selected frequency point indices

      call ind_rearrange(2*nmax+1,r,list)

      ! Extract selected frequencies

      dlrmf = ns(list(1:r))

      end subroutine dlr_mf





      !> Build transform matrix from values of a Green's function on
      !! Matsubara frequency grid to its DLR coefficients; matrix is
      !! stored in LU factored form
      !!
      !! To obtain the DLR coefficients of a Green's function from its
      !! values on the Matsubara frequency grid, use the dlr_mfexpnd
      !! subroutine with arrays mf2cf and mf2cfp generated by this
      !! subroutine.
      !!
      !! @param[in]  nmax    Matsubara frequency cutoff
      !! @param[in]  r         number of DLR basis functions
      !! @param[in]  dlrrf   DLR frequency nodes
      !! @param[in]  dlrmf   DLR Matsubara frequency nodes
      !! @param[out] mf2cf   Matsubara frequency grid values ->
      !!                       DLR coefficients transform matrix,
      !!                       stored in LAPACK LU factored format; LU
      !!                       factors
      !! @param[out] mf2cfp  Matsubra frequency grid values ->
      !!                       DLR coefficients transform matrix,
      !!                       stored in LAPACK LU factored format; LU
      !!                       pivots

      subroutine dlr_mf2cf(nmax,r,dlrrf,dlrmf,mf2cf,mf2cfp)

      implicit none
      integer nmax,r,dlrmf(r),mf2cfp(r)
      real *8 dlrrf(r)
      complex *16 mf2cf(r,r)

      integer j,k,info
      complex *16, external :: kfunf_mf

      ! Extract selected rows and columns of Fourier transformed K
      ! matrix

      do k=1,r
        do j=1,r
          mf2cf(j,k) = kfunf_mf(dlrmf(j),dlrrf(k))
        enddo
      enddo

      ! LU factorize

      call zgetrf(r,r,mf2cf,r,mf2cfp,info)

      end subroutine dlr_mf2cf





      !> Build transform matrix from DLR coefficients to values of DLR
      !! expansion on Matsubara frequency grid
      !!
      !! To obtain the values of a DLR expansion on the Matsubara
      !! frequency grid, apply the matrix cf2mf to the vector of DLR
      !! coefficients
      !!
      !! @param[in]  r      number of DLR basis functions
      !! @param[in]  dlrrf  DLR freq nodes
      !! @param[in]  dlrmf  DLR Matsubara freq nodes
      !! @param[out] cf2mf  DLR coeffs -> Matsubara freq grid
      !!                      values transform matrix



      subroutine dlr_cf2mf(r,dlrrf,dlrmf,cf2mf)

      implicit none
      integer r,dlrmf(r)
      real *8 dlrrf(r)
      complex *16 cf2mf(r,r)

      complex *16, external :: kfunf_mf

      integer i,j

      ! Evaluated Matsubara frequency kernel at selected real
      ! frequencies and Matsubara frequencies 

      do j=1,r
        do i=1,r
          cf2mf(i,j) = kfunf_mf(dlrmf(i),dlrrf(j))
        enddo
      enddo

      end subroutine dlr_cf2mf





      !> Get DLR coefficients of a Green's function from its values on the
      !! Matsubara frequency grid
      !!
      !! @param[in]  r       number of DLR basis functions
      !! @param[in]  mf2cf   Matsubara frequency grid values ->
      !!                       DLR coefficients transform matrix,
      !!                       stored in LAPACK LU factored format; LU
      !!                       factors
      !! @param[in]  mf2cfp  Matsubra frequency grid values ->
      !!                       DLR coefficients transform matrix,
      !!                       stored in LAPACK LU factored format; LU
      !!                       pivots
      !! @param[in]  g       values of Green's function at Matsubara
      !!                       freq grid points
      !! @param[out] gc      DLR coefficients of Green's function

      subroutine dlr_mfexpnd(r,mf2cf,mf2cfp,g,gc)

      implicit none
      integer r,mf2cfp(r)
      real *8 gc(r)
      complex *16 mf2cf(r,r),g(r)

      integer info
      complex *16, allocatable :: tmp(:)

      ! Backsolve with DLR transform matrix in factored form

      allocate(tmp(r))

      tmp = g

      call zgetrs('N',r,1,mf2cf,r,mf2cfp,tmp,r,info)

      gc = real(tmp)

      end subroutine dlr_mfexpnd





      !> Evaluate a DLR expansion at a fermionic Matsubara frequency
      !! point i*omega_n = i*(2n+1)
      !!
      !! @param[in]  r      number of DLR basis functions
      !! @param[in]  dlrrf  DLR frequency nodes
      !! @param[in]  gc     DLR coefficients of expansion
      !! @param[in]  n      Matsubara frequency integer
      !! @param[out] gn     value of DLR expansion at i*omega_n

      subroutine dlr_mf_eval(r,dlrrf,gc,n,gn)

      implicit none
      integer r,n
      real *8 dlrrf(r),gc(r)
      complex *16 gn

      integer i
      complex *16 kval
      complex *16, external :: kfunf_mf

      gn = (0.0d0,0.0d0)
      do i=1,r

        kval = kfunf_mf(n,dlrrf(i))

        gn = gn + gc(i)*kval

      enddo

      end subroutine dlr_mf_eval




