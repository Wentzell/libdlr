      !
      !
      ! This file contains subroutines to work with the discrete Lehmann
      ! representation in Matsubara frequency
      !
      !




      !> Get DLR frequency nodes and Matsubara frequency nodes
      !!
      !! @param[in]     lambda  dimensionless cutoff parameter
      !! @param[in]     eps     DLR error tolerance
      !! @param[in]     nmax    Matsubara frequency cutoff
      !! @param[in,out] rank    On input, maximum possible number of DLR
      !!                          basis functions, defining input size
      !!                          of various arrays; on output, number
      !!                          of DLR basis functions.
      !! @param[out]    dlrrf   DLR frequency nodes
      !! @param[out]    dlrmf   DLR Matsubara frequency nodes

      subroutine dlr_buildmf(lambda,eps,nmax,rank,dlrrf,dlrmf)

      implicit none
      integer nmax,rank,dlrmf(rank)
      real *8 lambda,eps,dlrrf(rank)

      integer p,npt,npo,nt,no
      integer, allocatable :: oidx(:)
      real *8 kerr(2)
      real *8, allocatable :: kmat(:,:),t(:),om(:)


      ! Set parameters for the fine grid based on lambda

      call gridparams(lambda,p,npt,npo,nt,no)


      ! Get fine composite Chebyshev discretization of K(tau,omega)

      allocate(kmat(nt,no),t(nt),om(no))

      call kfine_cc(lambda,p,npt,npo,t,om,kmat,kerr)


      ! Select real frequency points for DLR basis

      rank = 500 ! Upper bound on possible rank

      allocate(oidx(rank))

      call dlr_rf(lambda,eps,nt,no,om,kmat,rank,dlrrf,oidx)


      ! Get DLR Matsubara frequency grid

      call dlr_mf(nmax,rank,dlrrf,dlrmf)

      end subroutine dlr_buildmf





      !> Get DLR Matsubara frequency nodes
      !!
      !! @param[in]  nmax   Matsubara frequency cutoff
      !! @param[in]  rank   number of DLR basis functions
      !! @param[in]  dlrrf  DLR frequency nodes
      !! @param[out] dlrmf  DLR Matsubara frequency nodes

      subroutine dlr_mf(nmax,rank,dlrrf,dlrmf)

      implicit none
      integer nmax,rank,dlrmf(rank)
      real *8 dlrrf(rank)

      integer i,k,info
      integer, allocatable :: ns(:),list(:)
      real *8, allocatable :: work(:)
      complex *16, allocatable :: poles(:,:)
      complex *16, external :: kfunf_mf

      ! Get matrix of Fourier transforms of DLR basis functions

      allocate(poles(rank,2*nmax+1),ns(2*nmax+1))

      ns = (/(i, i=-nmax,nmax)/)

      do i=1,2*nmax+1
        do k=1,rank
          
          poles(k,i) = kfunf_mf(ns(i),dlrrf(k))
          
        enddo
      enddo

      ! --- Select Matsubara frequency nodes by pivoted QR on rows of
      ! Fourier transformed K matrix ---

      allocate(list(2*nmax+1),work(2*nmax+1))

      ! Pivoted QR

      call idzr_qrpiv(rank,2*nmax+1,poles,rank,list,work)

      ! Rearrange indices to get selected frequency point indices

      call ind_rearrange(2*nmax+1,rank,list)

      ! Extract selected frequencies

      dlrmf = ns(list(1:rank))

      end subroutine dlr_mf





      !> Build transform matrix from values of a Green's function on
      !! Matsubara frequency grid to its DLR coefficients; matrix is
      !! stored in LU factored form
      !!
      !! To obtain the DLR coefficients of a Green's function from its
      !! values on the Matsubara frequency grid, use the dlr_mfexpnd
      !! subroutine with arrays mf2cf and mf2cfpiv generated by this
      !! subroutine.
      !!
      !! @param[in]  nmax      Matsubara frequency cutoff
      !! @param[in]  rank      number of DLR basis functions
      !! @param[in]  dlrrf     DLR frequency nodes
      !! @param[in]  dlrmf     DLR Matsubara frequency nodes
      !! @param[out] mf2cf     Matsubara frequency grid values ->
      !!                         DLR coefficients transform matrix,
      !!                         stored in LAPACK LU factored format; LU
      !!                         factors
      !! @param[out] mf2cfpiv  Matsubra frequency grid values ->
      !!                         DLR coefficients transform matrix,
      !!                         stored in LAPACK LU factored format; LU
      !!                         pivots

      subroutine dlr_mf2cf(nmax,rank,dlrrf,dlrmf,mf2cf,mf2cfpiv)

      implicit none
      integer nmax,rank,dlrmf(rank),mf2cfpiv(rank)
      real *8 dlrrf(rank)
      complex *16 mf2cf(rank,rank)

      integer j,k,info
      complex *16, external :: kfunf_mf

      ! Extract selected rows and columns of Fourier transformed K
      ! matrix

      do k=1,rank
        do j=1,rank
          mf2cf(j,k) = kfunf_mf(dlrmf(j),dlrrf(k))
        enddo
      enddo

      ! LU factorize

      call zgetrf(rank,rank,mf2cf,rank,mf2cfpiv,info)

      end subroutine dlr_mf2cf





      !> Build transform matrix from DLR coefficients to values of DLR
      !! expansion on Matsubara frequency grid
      !!
      !! To obtain the values of a DLR expansion on the Matsubara
      !! frequency grid, apply the matrix cf2mf to the vector of DLR
      !! coefficients
      !!
      !! @param[in]  rank   number of DLR basis functions
      !! @param[in]  dlrrf  DLR freq nodes
      !! @param[in]  dlrmf  DLR Matsubara freq nodes
      !! @param[out] cf2mf  DLR coeffs -> Matsubara freq grid
      !!                      values transform matrix



      subroutine dlr_cf2mf(rank,dlrrf,dlrmf,cf2mf)

      implicit none
      integer rank,dlrmf(rank)
      real *8 dlrrf(rank)
      complex *16 cf2mf(rank,rank)

      complex *16, external :: kfunf_mf

      integer i,j

      ! Evaluated Matsubara frequency kernel at selected real
      ! frequencies and Matsubara frequencies 

      do j=1,rank
        do i=1,rank
          cf2mf(i,j) = kfunf_mf(dlrmf(i),dlrrf(j))
        enddo
      enddo

      end subroutine dlr_cf2mf





      !> Get DLR coefficients of a Green's function from its values on the
      !! Matsubara frequency grid
      !!
      !! @param[in]  rank      number of DLR basis functions
      !! @param[in]  mf2cf     Matsubara frequency grid values ->
      !!                         DLR coefficients transform matrix,
      !!                         stored in LAPACK LU factored format; LU
      !!                         factors
      !! @param[in]  mf2cfpiv  Matsubra frequency grid values ->
      !!                         DLR coefficients transform matrix,
      !!                         stored in LAPACK LU factored format; LU
      !!                         pivots
      !! @param[in]  g         values of Green's function at Matsubara
      !!                         freq grid points
      !! @param[out] gc        DLR coefficients of Green's function

      subroutine dlr_mfexpnd(rank,mf2cf,mf2cfpiv,g,gc)

      implicit none
      integer rank,mf2cfpiv(rank)
      real *8 gc(rank)
      complex *16 mf2cf(rank,rank),g(rank)

      integer info
      complex *16, allocatable :: tmp(:)

      ! Backsolve with DLR transform matrix in factored form

      allocate(tmp(rank))

      tmp = g

      call zgetrs('N',rank,1,mf2cf,rank,mf2cfpiv,tmp,rank,info)

      gc = real(tmp)

      end subroutine dlr_mfexpnd





      !> Evaluate a DLR expansion at a fermionic Matsubara frequency
      !! point i*omega_n = i*(2n+1)
      !!
      !! @param[in]  rank   number of DLR basis functions
      !! @param[in]  dlrrf  DLR frequency nodes
      !! @param[in]  gc     DLR coefficients of expansion
      !! @param[in]  n      Matsubara frequency integer
      !! @param[out] gn     value of DLR expansion at i*omega_n

      subroutine dlr_mf_eval(rank,dlrrf,gc,n,gn)

      implicit none
      integer rank,n
      real *8 dlrrf(rank),gc(rank)
      complex *16 gn

      integer i
      complex *16 kval
      complex *16, external :: kfunf_mf

      gn = (0.0d0,0.0d0)
      do i=1,rank

        kval = kfunf_mf(n,dlrrf(i))

        gn = gn + gc(i)*kval

      enddo

      end subroutine dlr_mf_eval




